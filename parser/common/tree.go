/*
 * Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
 *
 * WSO2 LLC. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package common

type SyntaxKind int

const (
	PUBLIC_KEYWORD SyntaxKind = iota
	PRIVATE_KEYWORD
	REMOTE_KEYWORD
	ABSTRACT_KEYWORD
	CLIENT_KEYWORD
	IMPORT_KEYWORD
	FUNCTION_KEYWORD
	CONST_KEYWORD
	LISTENER_KEYWORD
	SERVICE_KEYWORD
	XMLNS_KEYWORD
	ANNOTATION_KEYWORD
	TYPE_KEYWORD
	RECORD_KEYWORD
	OBJECT_KEYWORD
	AS_KEYWORD
	ON_KEYWORD
	RESOURCE_KEYWORD
	FINAL_KEYWORD
	SOURCE_KEYWORD
	WORKER_KEYWORD
	PARAMETER_KEYWORD
	FIELD_KEYWORD
	ISOLATED_KEYWORD

	RETURNS_KEYWORD
	RETURN_KEYWORD
	EXTERNAL_KEYWORD
	TRUE_KEYWORD
	FALSE_KEYWORD
	IF_KEYWORD
	ELSE_KEYWORD
	WHILE_KEYWORD
	CHECK_KEYWORD
	CHECKPANIC_KEYWORD
	PANIC_KEYWORD
	CONTINUE_KEYWORD
	BREAK_KEYWORD
	TYPEOF_KEYWORD
	IS_KEYWORD
	NULL_KEYWORD
	LOCK_KEYWORD
	FORK_KEYWORD
	TRAP_KEYWORD
	IN_KEYWORD
	FOREACH_KEYWORD
	TABLE_KEYWORD
	KEY_KEYWORD
	LET_KEYWORD
	NEW_KEYWORD
	FROM_KEYWORD
	WHERE_KEYWORD
	SELECT_KEYWORD
	START_KEYWORD
	FLUSH_KEYWORD
	CONFIGURABLE_KEYWORD
	WAIT_KEYWORD
	DO_KEYWORD
	TRANSACTION_KEYWORD
	TRANSACTIONAL_KEYWORD
	COMMIT_KEYWORD
	ROLLBACK_KEYWORD
	RETRY_KEYWORD
	ENUM_KEYWORD
	BASE16_KEYWORD
	BASE64_KEYWORD
	MATCH_KEYWORD
	CONFLICT_KEYWORD
	LIMIT_KEYWORD
	JOIN_KEYWORD
	OUTER_KEYWORD
	EQUALS_KEYWORD
	CLASS_KEYWORD
	ORDER_KEYWORD
	BY_KEYWORD
	ASCENDING_KEYWORD
	DESCENDING_KEYWORD
	UNDERSCORE_KEYWORD
	NOT_IS_KEYWORD
	NATURAL_KEYWORD

	// Type keywords
	INT_KEYWORD
	BYTE_KEYWORD
	FLOAT_KEYWORD
	DECIMAL_KEYWORD
	STRING_KEYWORD
	BOOLEAN_KEYWORD
	XML_KEYWORD
	JSON_KEYWORD
	HANDLE_KEYWORD
	ANY_KEYWORD
	ANYDATA_KEYWORD
	NEVER_KEYWORD
	VAR_KEYWORD
	MAP_KEYWORD
	FUTURE_KEYWORD
	TYPEDESC_KEYWORD
	ERROR_KEYWORD
	STREAM_KEYWORD
	READONLY_KEYWORD
	DISTINCT_KEYWORD
	FAIL_KEYWORD

	// Contextual keywords
	RE_KEYWORD // Any kind above this is considered as a keyword
	GROUP_KEYWORD
	COLLECT_KEYWORD

	// Separators
	OPEN_BRACE_TOKEN
	CLOSE_BRACE_TOKEN
	OPEN_PAREN_TOKEN
	CLOSE_PAREN_TOKEN
	OPEN_BRACKET_TOKEN
	CLOSE_BRACKET_TOKEN
	SEMICOLON_TOKEN
	DOT_TOKEN
	COLON_TOKEN
	COMMA_TOKEN
	ELLIPSIS_TOKEN
	OPEN_BRACE_PIPE_TOKEN
	CLOSE_BRACE_PIPE_TOKEN
	AT_TOKEN
	HASH_TOKEN
	BACKTICK_TOKEN
	DOUBLE_QUOTE_TOKEN
	SINGLE_QUOTE_TOKEN
	DOUBLE_BACKTICK_TOKEN
	TRIPLE_BACKTICK_TOKEN

	// Operators
	EQUAL_TOKEN
	DOUBLE_EQUAL_TOKEN
	TRIPPLE_EQUAL_TOKEN
	PLUS_TOKEN
	MINUS_TOKEN
	SLASH_TOKEN
	PERCENT_TOKEN
	ASTERISK_TOKEN
	LT_TOKEN
	LT_EQUAL_TOKEN
	GT_TOKEN
	RIGHT_DOUBLE_ARROW_TOKEN
	QUESTION_MARK_TOKEN
	PIPE_TOKEN
	GT_EQUAL_TOKEN
	EXCLAMATION_MARK_TOKEN
	NOT_EQUAL_TOKEN
	NOT_DOUBLE_EQUAL_TOKEN
	BITWISE_AND_TOKEN
	BITWISE_XOR_TOKEN
	LOGICAL_AND_TOKEN
	LOGICAL_OR_TOKEN
	NEGATION_TOKEN
	RIGHT_ARROW_TOKEN
	INTERPOLATION_START_TOKEN
	XML_PI_START_TOKEN
	XML_PI_END_TOKEN
	XML_COMMENT_START_TOKEN
	XML_COMMENT_END_TOKEN
	SYNC_SEND_TOKEN
	LEFT_ARROW_TOKEN
	DOUBLE_DOT_LT_TOKEN
	DOUBLE_LT_TOKEN
	ANNOT_CHAINING_TOKEN
	OPTIONAL_CHAINING_TOKEN
	ELVIS_TOKEN
	DOT_LT_TOKEN
	SLASH_LT_TOKEN
	DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN
	SLASH_ASTERISK_TOKEN
	DOUBLE_GT_TOKEN
	TRIPPLE_GT_TOKEN
	XML_CDATA_START_TOKEN
	XML_CDATA_END_TOKEN
	BACK_SLASH_TOKEN
	DOLLAR_TOKEN
	ESCAPED_MINUS_TOKEN

	// Documentation reference types
	TYPE_DOC_REFERENCE_TOKEN
	SERVICE_DOC_REFERENCE_TOKEN
	VARIABLE_DOC_REFERENCE_TOKEN
	VAR_DOC_REFERENCE_TOKEN
	ANNOTATION_DOC_REFERENCE_TOKEN
	MODULE_DOC_REFERENCE_TOKEN
	FUNCTION_DOC_REFERENCE_TOKEN
	PARAMETER_DOC_REFERENCE_TOKEN
	CONST_DOC_REFERENCE_TOKEN

	// Literal tokens
	IDENTIFIER_TOKEN
	STRING_LITERAL_TOKEN
	DECIMAL_INTEGER_LITERAL_TOKEN
	HEX_INTEGER_LITERAL_TOKEN
	DECIMAL_FLOATING_POINT_LITERAL_TOKEN
	HEX_FLOATING_POINT_LITERAL_TOKEN
	XML_TEXT_CONTENT
	TEMPLATE_STRING
	PROMPT_CONTENT

	// Documentation
	DOCUMENTATION_DESCRIPTION
	PARAMETER_NAME
	CODE_CONTENT
	DEPRECATION_LITERAL
	DOCUMENTATION_STRING

	// Other
	INVALID_TOKEN

	//-----------------------------------------------non-terminal-kinds-----------------------------------------------

	// Minutiae kinds
	WHITESPACE_MINUTIAE
	END_OF_LINE_MINUTIAE
	COMMENT_MINUTIAE
	INVALID_NODE_MINUTIAE

	// Invalid nodes
	INVALID_TOKEN_MINUTIAE_NODE

	// module-level declarations
	IMPORT_DECLARATION
	FUNCTION_DEFINITION
	TYPE_DEFINITION
	SERVICE_DECLARATION
	MODULE_VAR_DECL
	LISTENER_DECLARATION
	CONST_DECLARATION
	ANNOTATION_DECLARATION
	MODULE_XML_NAMESPACE_DECLARATION
	ENUM_DECLARATION
	CLASS_DEFINITION

	// Statements
	BLOCK_STATEMENT
	LOCAL_VAR_DECL
	ASSIGNMENT_STATEMENT
	IF_ELSE_STATEMENT
	ELSE_BLOCK
	WHILE_STATEMENT
	CALL_STATEMENT
	PANIC_STATEMENT
	RETURN_STATEMENT
	CONTINUE_STATEMENT
	BREAK_STATEMENT
	COMPOUND_ASSIGNMENT_STATEMENT
	LOCAL_TYPE_DEFINITION_STATEMENT
	ACTION_STATEMENT
	LOCK_STATEMENT
	NAMED_WORKER_DECLARATION
	FORK_STATEMENT
	FOREACH_STATEMENT
	TRANSACTION_STATEMENT
	ROLLBACK_STATEMENT
	RETRY_STATEMENT
	XML_NAMESPACE_DECLARATION
	MATCH_STATEMENT
	INVALID_EXPRESSION_STATEMENT
	DO_STATEMENT
	FAIL_STATEMENT

	// Expressions
	BINARY_EXPRESSION
	BRACED_EXPRESSION
	FUNCTION_CALL
	QUALIFIED_NAME_REFERENCE
	INDEXED_EXPRESSION
	FIELD_ACCESS
	METHOD_CALL
	CHECK_EXPRESSION
	MAPPING_CONSTRUCTOR
	TYPEOF_EXPRESSION
	UNARY_EXPRESSION
	TYPE_TEST_EXPRESSION
	SIMPLE_NAME_REFERENCE
	TRAP_EXPRESSION
	LIST_CONSTRUCTOR
	TYPE_CAST_EXPRESSION
	TABLE_CONSTRUCTOR
	LET_EXPRESSION
	XML_TEMPLATE_EXPRESSION
	REGEX_TEMPLATE_EXPRESSION
	RAW_TEMPLATE_EXPRESSION
	STRING_TEMPLATE_EXPRESSION
	IMPLICIT_NEW_EXPRESSION
	EXPLICIT_NEW_EXPRESSION
	PARENTHESIZED_ARG_LIST
	EXPLICIT_ANONYMOUS_FUNCTION_EXPRESSION
	IMPLICIT_ANONYMOUS_FUNCTION_EXPRESSION
	QUERY_EXPRESSION
	ANNOT_ACCESS
	OPTIONAL_FIELD_ACCESS
	CONDITIONAL_EXPRESSION
	TRANSACTIONAL_EXPRESSION
	OBJECT_CONSTRUCTOR
	XML_FILTER_EXPRESSION
	XML_STEP_EXPRESSION
	XML_NAME_PATTERN_CHAIN
	XML_ATOMIC_NAME_PATTERN
	STRING_LITERAL
	NUMERIC_LITERAL
	BOOLEAN_LITERAL
	NIL_LITERAL
	NULL_LITERAL
	BYTE_ARRAY_LITERAL
	ASTERISK_LITERAL
	REQUIRED_EXPRESSION
	ERROR_CONSTRUCTOR
	XML_STEP_METHOD_CALL_EXTEND
	XML_STEP_INDEXED_EXTEND
	NATURAL_EXPRESSION

	// Type descriptors
	TYPE_DESC
	RECORD_TYPE_DESC
	OBJECT_TYPE_DESC
	NIL_TYPE_DESC
	OPTIONAL_TYPE_DESC
	ARRAY_TYPE_DESC
	INT_TYPE_DESC
	BYTE_TYPE_DESC
	FLOAT_TYPE_DESC
	DECIMAL_TYPE_DESC
	STRING_TYPE_DESC
	BOOLEAN_TYPE_DESC
	XML_TYPE_DESC
	JSON_TYPE_DESC
	HANDLE_TYPE_DESC
	ANY_TYPE_DESC
	ANYDATA_TYPE_DESC
	NEVER_TYPE_DESC
	VAR_TYPE_DESC
	SERVICE_TYPE_DESC
	MAP_TYPE_DESC
	UNION_TYPE_DESC
	ERROR_TYPE_DESC
	STREAM_TYPE_DESC
	TABLE_TYPE_DESC
	FUNCTION_TYPE_DESC
	TUPLE_TYPE_DESC
	PARENTHESISED_TYPE_DESC
	READONLY_TYPE_DESC
	DISTINCT_TYPE_DESC
	INTERSECTION_TYPE_DESC
	SINGLETON_TYPE_DESC
	TYPE_REFERENCE_TYPE_DESC
	TYPEDESC_TYPE_DESC
	FUTURE_TYPE_DESC

	// Actions
	REMOTE_METHOD_CALL_ACTION
	BRACED_ACTION
	CHECK_ACTION
	START_ACTION
	TRAP_ACTION
	FLUSH_ACTION
	ASYNC_SEND_ACTION
	SYNC_SEND_ACTION
	RECEIVE_ACTION
	WAIT_ACTION
	QUERY_ACTION
	COMMIT_ACTION
	CLIENT_RESOURCE_ACCESS_ACTION

	// Other
	RETURN_TYPE_DESCRIPTOR
	REQUIRED_PARAM
	DEFAULTABLE_PARAM
	REST_PARAM
	EXTERNAL_FUNCTION_BODY
	RECORD_FIELD
	RECORD_FIELD_WITH_DEFAULT_VALUE
	TYPE_REFERENCE
	RECORD_REST_TYPE
	POSITIONAL_ARG
	NAMED_ARG
	REST_ARG
	OBJECT_FIELD
	IMPORT_ORG_NAME
	MODULE_NAME
	SUB_MODULE_NAME
	IMPORT_VERSION
	ORDER_BY_CLAUSE
	IMPORT_PREFIX
	SPECIFIC_FIELD
	COMPUTED_NAME_FIELD
	SPREAD_FIELD
	ORDER_KEY
	RESOURCE_ACCESSOR_DEFINITION
	ANNOTATION
	METADATA
	ARRAY_DIMENSION
	ANNOTATION_ATTACH_POINT
	FUNCTION_BODY_BLOCK
	NAMED_WORKER_DECLARATOR
	EXPRESSION_FUNCTION_BODY
	TYPE_CAST_PARAM
	KEY_SPECIFIER
	EXPLICIT_TYPE_PARAMS
	LET_VAR_DECL
	STREAM_TYPE_PARAMS
	FUNCTION_SIGNATURE
	INFER_PARAM_LIST
	TYPE_PARAMETER
	KEY_TYPE_CONSTRAINT
	QUERY_CONSTRUCT_TYPE
	FROM_CLAUSE
	WHERE_CLAUSE
	LET_CLAUSE
	QUERY_PIPELINE
	SELECT_CLAUSE
	METHOD_DECLARATION
	TYPED_BINDING_PATTERN
	BINDING_PATTERN
	CAPTURE_BINDING_PATTERN
	REST_BINDING_PATTERN
	LIST_BINDING_PATTERN
	RECEIVE_FIELDS
	REST_TYPE
	WAIT_FIELDS_LIST
	WAIT_FIELD
	ENUM_MEMBER
	BRACKETED_LIST
	LIST_BP_OR_LIST_CONSTRUCTOR
	MAPPING_BINDING_PATTERN
	FIELD_BINDING_PATTERN
	MAPPING_BP_OR_MAPPING_CONSTRUCTOR
	WILDCARD_BINDING_PATTERN
	MATCH_CLAUSE
	MATCH_GUARD
	OBJECT_METHOD_DEFINITION
	ON_CONFLICT_CLAUSE
	LIMIT_CLAUSE
	JOIN_CLAUSE
	ON_CLAUSE
	LIST_MATCH_PATTERN
	REST_MATCH_PATTERN
	MAPPING_MATCH_PATTERN
	FIELD_MATCH_PATTERN
	ERROR_MATCH_PATTERN
	NAMED_ARG_MATCH_PATTERN
	ERROR_BINDING_PATTERN
	NAMED_ARG_BINDING_PATTERN
	TUPLE_TYPE_DESC_OR_LIST_CONST
	ON_FAIL_CLAUSE
	RESOURCE_ACCESSOR_DECLARATION
	RESOURCE_PATH_SEGMENT_PARAM
	RESOURCE_PATH_REST_PARAM
	INCLUDED_RECORD_PARAM
	ARRAY_TYPE_DESC_OR_MEMBER_ACCESS
	INFERRED_TYPEDESC_DEFAULT
	SPREAD_MEMBER
	COMPUTED_RESOURCE_ACCESS_SEGMENT
	RESOURCE_ACCESS_REST_SEGMENT
	MEMBER_TYPE_DESC
	GROUPING_KEY_VAR_DECLARATION
	GROUPING_KEY_VAR_NAME
	GROUP_BY_CLAUSE
	COLLECT_CLAUSE
	ALTERNATE_RECEIVE
	RECEIVE_FIELD

	// XML
	XML_ELEMENT
	XML_EMPTY_ELEMENT
	XML_TEXT
	XML_COMMENT
	XML_PI
	XML_ELEMENT_START_TAG
	XML_ELEMENT_END_TAG
	XML_SIMPLE_NAME
	XML_QUALIFIED_NAME
	XML_ATTRIBUTE
	XML_ATTRIBUTE_VALUE
	INTERPOLATION
	XML_CDATA

	// Reg Exp
	RE_SEQUENCE
	RE_ATOM_QUANTIFIER
	RE_ASSERTION
	RE_LITERAL_CHAR_DOT_OR_ESCAPE
	RE_QUOTE_ESCAPE
	RE_SIMPLE_CHAR_CLASS_ESCAPE
	RE_UNICODE_PROPERTY_ESCAPE
	RE_UNICODE_SCRIPT
	RE_UNICODE_GENERAL_CATEGORY
	RE_CHARACTER_CLASS
	RE_CHAR_SET_ATOM_WITH_RE_CHAR_SET_NO_DASH
	RE_CHAR_SET_ATOM_NO_DASH_WITH_RE_CHAR_SET_NO_DASH
	RE_CHAR_SET_RANGE
	RE_CHAR_SET_RANGE_NO_DASH
	RE_CHAR_SET_RANGE_WITH_RE_CHAR_SET
	RE_CHAR_SET_RANGE_NO_DASH_WITH_RE_CHAR_SET
	RE_CAPTURING_GROUP
	RE_FLAG_EXPR
	RE_FLAGS_ON_OFF
	RE_FLAGS
	RE_QUANTIFIER
	RE_BRACED_QUANTIFIER

	RE_ASSERTION_VALUE
	RE_LITERAL_CHAR
	RE_NUMERIC_ESCAPE
	RE_CONTROL_ESCAPE
	RE_SIMPLE_CHAR_CLASS_CODE
	RE_PROPERTY
	RE_UNICODE_SCRIPT_START
	RE_UNICODE_PROPERTY_VALUE
	RE_UNICODE_GENERAL_CATEGORY_START
	RE_UNICODE_GENERAL_CATEGORY_NAME
	RE_CHAR_SET_ATOM_NO_DASH
	RE_FLAGS_VALUE
	RE_BASE_QUANTIFIER_VALUE
	DIGIT

	// Documentation
	MARKDOWN_DOCUMENTATION
	MARKDOWN_DOCUMENTATION_LINE
	MARKDOWN_REFERENCE_DOCUMENTATION_LINE
	MARKDOWN_PARAMETER_DOCUMENTATION_LINE
	MARKDOWN_RETURN_PARAMETER_DOCUMENTATION_LINE
	MARKDOWN_DEPRECATION_DOCUMENTATION_LINE
	MARKDOWN_CODE_LINE
	BALLERINA_NAME_REFERENCE
	MARKDOWN_CODE_BLOCK
	INLINE_CODE_REFERENCE

	INVALID
	MODULE_PART
	EOF_TOKEN
	LIST
	NONE
)

var syntaxKind = []string{
	"public",
	"private",
	"remote",
	"abstract",
	"client",
	"import",
	"function",
	"const",
	"listener",
	"service",
	"xmlns",
	"annotation",
	"type",
	"record",
	"object",
	"as",
	"on",
	"resource",
	"final",
	"source",
	"worker",
	"parameter",
	"field",
	"isolated",

	"returns",
	"return",
	"external",
	"true",
	"false",
	"if",
	"else",
	"while",
	"check",
	"checkpanic",
	"panic",
	"continue",
	"break",
	"typeof",
	"is",
	"null",
	"lock",
	"fork",
	"trap",
	"in",
	"foreach",
	"table",
	"key",
	"let",
	"new",
	"from",
	"where",
	"select",
	"start",
	"flush",
	"configurable",
	"wait",
	"do",
	"transaction",
	"transactional",
	"commit",
	"rollback",
	"retry",
	"enum",
	"base16",
	"base64",
	"match",
	"conflict",
	"limit",
	"join",
	"outer",
	"equals",
	"class",
	"order",
	"by",
	"ascending",
	"descending",
	"_",
	"!is",
	"natural",

	// Type keywords
	"int",
	"byte",
	"float",
	"decimal",
	"string",
	"boolean",
	"xml",
	"json",
	"handle",
	"any",
	"anydata",
	"never",
	"var",
	"map",
	"future",
	"typedesc",
	"error",
	"stream",
	"readonly",
	"distinct",
	"fail",

	// Contextual keywords
	"re", // Any kind above this is considered as a keyword
	"group",
	"collect",

	// Separators
	"{",
	"}",
	"(",
	")",
	"[",
	"]",
	";",
	".",
	":",
	",",
	"...",
	"{|",
	"|}",
	"@",
	"#",
	"`",
	"",
	"'",
	"``",
	"```",

	// Operators
	"=",
	"==",
	"===",
	"+",
	"-",
	"/",
	"%",
	"*",
	"<",
	"<=",
	">",
	"=>",
	"?",
	"|",
	">=",
	"!",
	"!=",
	"!==",
	"&",
	"^",
	"&&",
	"||",
	"~",
	"->",
	"${",
	"<?",
	"?>",
	"<!--",
	"-->",
	"->>",
	"<-",
	"..<",
	"<<",
	".@",
	"?.",
	"?:",
	".<",
	"/<",
	"/**/<",
	"/*",
	">>",
	">>>",
	"<![CDATA[",
	"]]>",
	"\\",
	"$",
	"\\-",

	// Documentation reference types
	"type",
	"service",
	"variable",
	"var",
	"annotation",
	"module",
	"function",
	"parameter",
	"const",
}

func (sk SyntaxKind) StrValue() string {
	if sk > CONST_DOC_REFERENCE_TOKEN {
		return ""
	}
	return syntaxKind[sk]
}

func (sk SyntaxKind) Tag() int {
	switch {
	case sk >= PUBLIC_KEYWORD && sk < IMPORT_KEYWORD:
		return 50 + int(sk)
	case sk >= IMPORT_KEYWORD && sk < AS_KEYWORD:
		return 100 + int(sk) - int(IMPORT_KEYWORD)
	case sk >= AS_KEYWORD && sk < RETURNS_KEYWORD:
		return 111 + int(sk) - int(AS_KEYWORD)
	case sk >= RETURNS_KEYWORD && sk < INT_KEYWORD:
		return 200 + int(sk) - int(RETURNS_KEYWORD)
	case sk >= INT_KEYWORD && sk < RE_KEYWORD:
		return 300 + int(sk) - int(INT_KEYWORD)
	case sk >= RE_KEYWORD && sk < OPEN_BRACE_TOKEN:
		return 400 + int(sk) - int(RE_KEYWORD)
	case sk >= OPEN_BRACE_TOKEN && sk < EQUAL_TOKEN:
		return 500 + int(sk) - int(OPEN_BRACE_TOKEN)
	case sk >= EQUAL_TOKEN && sk < TYPE_DOC_REFERENCE_TOKEN:
		return 550 + int(sk) - int(EQUAL_TOKEN)
	case sk >= TYPE_DOC_REFERENCE_TOKEN && sk < IDENTIFIER_TOKEN:
		return 900 + int(sk) - int(TYPE_DOC_REFERENCE_TOKEN)
	case sk >= IDENTIFIER_TOKEN && sk < DOCUMENTATION_DESCRIPTION:
		return 1000 + int(sk) - int(IDENTIFIER_TOKEN)
	case sk >= DOCUMENTATION_DESCRIPTION && sk < INVALID_TOKEN:
		return 1100 + int(sk) - int(DOCUMENTATION_DESCRIPTION)
	case sk == INVALID_TOKEN:
		return 1191
	case sk >= WHITESPACE_MINUTIAE && sk < INVALID_TOKEN_MINUTIAE_NODE:
		return 1500 + int(sk) - int(WHITESPACE_MINUTIAE)
	case sk == INVALID_TOKEN_MINUTIAE_NODE:
		return 1601
	case sk >= IMPORT_DECLARATION && sk < BLOCK_STATEMENT:
		return 2000 + int(sk) - int(IMPORT_DECLARATION)
	case sk >= BLOCK_STATEMENT && sk < BINARY_EXPRESSION:
		return 1200 + int(sk) - int(BLOCK_STATEMENT)
	case sk >= BINARY_EXPRESSION && sk < TYPE_DESC:
		return 1300 + int(sk) - int(BINARY_EXPRESSION)
	case sk >= TYPE_DESC && sk < REMOTE_METHOD_CALL_ACTION:
		return 2000 + int(sk) - int(TYPE_DESC)
	case sk >= REMOTE_METHOD_CALL_ACTION && sk < RETURN_TYPE_DESCRIPTOR:
		return 2500 + int(sk) - int(REMOTE_METHOD_CALL_ACTION)
	case sk >= RETURN_TYPE_DESCRIPTOR && sk < XML_ELEMENT:
		return 3000 + int(sk) - int(RETURN_TYPE_DESCRIPTOR)
	case sk >= XML_ELEMENT && sk < MARKDOWN_DOCUMENTATION:
		return 4000 + int(sk) - int(XML_ELEMENT)
	case sk >= MARKDOWN_DOCUMENTATION && sk < INVALID:
		return 4500 + int(sk) - int(MARKDOWN_DOCUMENTATION)
	case sk == INVALID:
		return 4
	case sk == MODULE_PART:
		return 3
	case sk == EOF_TOKEN:
		return 2
	case sk == LIST:
		return 1
	case sk == NONE:
		return 0
	}
	panic("Unexpected syntax kind")
}
